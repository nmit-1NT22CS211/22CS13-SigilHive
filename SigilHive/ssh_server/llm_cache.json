{"resp:7990c16a464314a0367203a0": "const express = require('express');\nconst dotenv = require('dotenv');\nconst mongoose = require('require');\nconst redis = require('redis');\nconst morgan = require('morgan');\nconst helmet = require('helmet');\nconst cookieParser = require('cookie-parser');\nconst cors = require('cors');\n\n// Load environment variables\ndotenv.config();\n\nconst app = express();\n\n// Connect to MongoDB\nmongoose.connect(process.env.MONGO_URI, {\n    useNewUrlParser: true,\n    useUnifiedTopology: true,\n    useCreateIndex: true,\n    useFindAndModify: false\n})\n.then(() => console.log('MongoDB Connected...'))\n.catch(err => console.error('MongoDB connection error:', err));\n\n// Connect to Redis\nconst redisClient = redis.createClient({\n    url: process.env.REDIS_URL\n});\nredisClient.on('connect', () => console.log('Redis Connected...'));\nredisClient.on('error', err => console.error('Redis connection error:', err));\nredisClient.connect(); // For redis v4+\n\n// Middleware\napp.use(express.json()); // Body parser for JSON\napp.use(express.urlencoded({ extended: true })); // Body parser for URL-encoded data\napp.use(cookieParser());\napp.use(helmet()); // Security headers\napp.use(morgan('dev')); // HTTP request logger\n\nconst corsOptions = {\n    origin: process.env.CLIENT_URL, // Allow requests from our frontend\n    credentials: true,\n    optionsSuccessStatus: 200\n};\napp.use(cors(corsOptions));\n\n// Import Routes\nconst authRoutes = require('./routes/auth');\nconst productRoutes = require('./routes/product');\nconst orderRoutes = require('./routes/order');\nconst userRoutes = require('./routes/user');\nconst cartRoutes = require('./routes/cart');\n\n// Route Middlewares\napp.use('/api/auth', authRoutes);\napp.use('/api/products', productRoutes);\napp.use('/api/orders', orderRoutes);\napp.use('/api/users', userRoutes);\napp.use('/api/cart', cartRoutes);\n\n// Basic route\napp.get('/', (req, res) => {\n    res.send('ShopHub API is running!');\n});\n\n// Error handling middleware (catch-all)\napp.use((err, req, res, next) => {\n    console.error(err.stack);\n    res.status(err.statusCode || 500).json({\n        success: false,\n        message: err.message || 'Server Error'\n    });\n});\n\nconst PORT = process.env.PORT || 5000;\n\napp.listen(PORT, () => {\n    console.log(`Server running on port ${PORT}`);\n});\n\nmodule.exports = app;", "resp:9b2883e58b5c339f5f14ce36": "const User = require('../models/User');\nconst jwt = require('jsonwebtoken');\nconst bcrypt = require('bcryptjs');\n\n// Environment variables for JWT secret (example placeholder)\nconst JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-for-development';\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '1h';\n\n/**\n * @desc    Register a new user\n * @route   POST /api/auth/register\n * @access  Public\n */\nexports.register = async (req, res) => {\n    const { username, email, password } = req.body;\n\n    try {\n        let user = await User.findOne({ email });\n        if (user) {\n            return res.status(400).json({ msg: 'User already exists' });\n        }\n\n        user = new User({\n            username,\n            email,\n            password\n        });\n\n        const salt = await bcrypt.genSalt(10);\n        user.password = await bcrypt.hash(password, salt);\n\n        await user.save();\n\n        const payload = {\n            user: {\n                id: user.id,\n                role: user.role // Assuming a role field\n            }\n        };\n\n        jwt.sign(\n            payload,\n            JWT_SECRET,\n            { expiresIn: JWT_EXPIRES_IN },\n            (err, token) => {\n                if (err) throw err;\n                res.json({ token });\n            }\n        );\n\n    } catch (err) {\n        console.error(err.message);\n        res.status(500).send('Server Error');\n    }\n};\n\n/**\n * @desc    Authenticate user & get token\n * @route   POST /api/auth/login\n * @access  Public\n */\nexports.login = async (req, res) => {\n    const { email, password } = req.body;\n\n    try {\n        let user = await User.findOne({ email });\n        if (!user) {\n            return res.status(400).json({ msg: 'Invalid Credentials' });\n        }\n\n        const isMatch = await bcrypt.compare(password, user.password);\n        if (!isMatch) {\n            return res.status(400).json({ msg: 'Invalid Credentials' });\n        }\n\n        const payload = {\n            user: {\n                id: user.id,\n                role: user.role\n            }\n        };\n\n        jwt.sign(\n            payload,\n            JWT_SECRET,\n            { expiresIn: JWT_EXPIRES_IN },\n            (err, token) => {\n                if (err) throw err;\n                res.json({ token });\n            }\n        );\n\n    } catch (err) {\n        console.error(err.message);\n        res.status(500).send('Server Error');\n    }\n};\n\n/**\n * @desc    Get logged in user profile\n * @route   GET /api/auth/me\n * @access  Private\n */\nexports.getMe = async (req, res) => {\n    try {\n        // req.user is populated by auth middleware\n        const user = await User.findById(req.user.id).select('-password');\n        res.json(user);\n    } catch (err) {\n        console.error(err.message);\n        res.status(500).send('Server Error');\n    }\n};\n\n/**\n * @desc    Log out user (client-side token removal)\n * @route   POST /api/auth/logout\n * @access  Public\n * @note    For JWTs, logout is typically handled client-side by deleting the token.\n *          This endpoint could be used to invalidate refresh tokens if implemented,\n *          or simply acknowledge client-side action.\n */\nexports.logout = (req, res) => {\n    // If using HTTP-only cookies for tokens:\n    // res.cookie('token', 'none', {\n    //     expires: new Date(Date.now() + 10 * 1000),\n    //     httpOnly: true\n    // });\n    res.status(200).json({ msg: 'Logged out successfully (client-side token removed)' });\n};", "resp:91d6e7533c62eaf14905ef28": "", "resp:acdcb4c723788cbee5ab41b7": "user@shophub-production-server:~/shophub/app/controllers$", "resp:78fe7e3d1e13e5c78c519f52": "user@shophub-dev:~$", "resp:9ba5bf96396d878072c2c634": "cat: .ssh: Is a directory", "resp:83682ac28ae328a92b1ad93a": "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDBp8fK7MvX2yZ0c2N6w9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7L6X1j8C5eR3oG4t9uF7", "resp:f606ee9e1282b36c8d2b7ca8": "", "resp:70586803e854d4c69e69715a": "bash: cd..: command not found", "resp:784c1a235f5b98335d0b6b15": "", "resp:16fa7fed9482520923506ebe": "1  ls -la\n    2  cd shophub/\n    3  ls\n    4  docker-compose ps\n    5  docker-compose logs --tail 50 web\n    6  cat .env\n    7  vi docker-compose.yml\n    8  docker-compose down\n    9  docker-compose up -d\n   10  git pull origin main\n   11  npm install\n   12  docker-compose build web\n   13  docker-compose up -d --build\n   14  docker ps\n   15  docker logs shophub_redis_1\n   16  df -h\n   17  free -h\n   18  top\n   19  grep \"ERROR\" logs/app.log | tail -n 20\n   20  tail -f logs/access.log\n   21  cat package.json\n   22  npm test\n   23  mongo --eval \"db.orders.countDocuments()\" shophub_db\n   24  redis-cli INFO | grep used_memory_human\n   25  sudo systemctl status nginx\n   26  cd ..\n   27  ls -F\n   28  cat README.md\n   29  ssh-keygen -t rsa -b 4096 -C \"admin@shophub.com\"\n   30  cat .bashrc\n   31  source .bashrc\n   32  history", "resp:28d8e141e40184afb455cb47": "cls: command not found"}